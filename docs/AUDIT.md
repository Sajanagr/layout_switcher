# Технический аудит проекта layout_switcher

## 1. Краткое описание проекта
- Скрипт `layout_switcher.py` перехватывает горячую клавишу (Scroll Lock или Win) и переключает раскладку **выделенного текста** (RU<->EN), дополнительно меняя системную раскладку. Файл: `layout_switcher.py`.
- Логика работы: hotkey → копирование выделения (Ctrl+C) → конвертация символов → вставка (Ctrl+V) → восстановление буфера обмена → переключение системной раскладки. Основной поток: `handle_key_press()` в `layout_switcher.py:135-177`.

## 2. Запуск и окружение
- Зависимости Python: `pyperclip`, `pynput` (см. `requirements.txt`).
- Запуск через `start.sh`: активирует `venv`, затем запускает `layout_switcher.py` (см. `start.sh:6-18`). Без `venv` — немедленный `exit 1`.
- systemd unit’ы:
  - `systemd/layout_switcher.service` — привязан к `graphical-session.target`, выставляет `DISPLAY=:0`, `XAUTHORITY=%h/.Xauthority`, `DBUS_SESSION_BUS_ADDRESS=...` (см. `systemd/layout_switcher.service:2-16`).
  - `systemd/layout_switcher_example.service` — похожий, но с жесткими sandbox-настройками и `WantedBy=default.target` (см. `systemd/layout_switcher_example.service:1-27`).
- Корректность unit’ов и окружение:
  - `DISPLAY=:0` и `XAUTHORITY=%h/.Xauthority` корректны **только для X11** и типичных конфигураций. На GNOME 46 (Ubuntu) по умолчанию Wayland — эти переменные могут отсутствовать или быть неверными.
  - Для GNOME/Wayland глобальные перехваты клавиш и управление буфером могут не работать из-за ограничений Wayland (pynput/pyperclip обычно требуют X11/XWayland).
  - `ExecStart` в `systemd/layout_switcher.service` указывает на `%h/projects/my/layout_switcher/start.sh` — путь не совпадает с текущим workspace и требует правки при установке.

## 3. Анализ кода (`layout_switcher.py`)
### Структура и глобальные состояния
- Глобальные словари `en_to_ru` и `ru_to_en` содержат таблицу преобразования (см. `layout_switcher.py:20-46`). Они статичны, без валидации парности.
- Глобальных mutable-состояний (кроме словарей) нет, вся логика внутри функций.

### Обработка клавиатуры (pynput)
- Используется `keyboard.Listener(on_press=...)` и `keyboard.Controller()` для эмуляции Ctrl+C/Ctrl+V (см. `layout_switcher.py:135-177`, `layout_switcher.py:218-222`).
- Hotkey реализован как перехват Scroll Lock (`on_press_scroll_lock`) или Win (`on_press_win`) — без подавления автоповтора и без debounce (см. `layout_switcher.py:179-189`).
- Под Wayland глобальный захват клавиш, как правило, не работает (ограничения GNOME 46). На X11/XWayland — работает.

### Буфер обмена (pyperclip)
- Скрипт сохраняет текущий буфер, затем перезаписывает его конвертированным текстом, и в конце восстанавливает исходное значение (см. `layout_switcher.py:135-177`).
- `is_text_in_clipboard()` пытается проверить, что в буфере текст (см. `layout_switcher.py:120-129`), но в `handle_key_press()` нет общего `try/except` — исключение `pyperclip.paste()` до `is_text_in_clipboard()` может привести к падению (см. `layout_switcher.py:135-139`).

### Конвертация раскладок
- Конвертация посимвольная, без учета контекста (см. `switch_layout()` в `layout_switcher.py:104-118`).
- Таблица в целом симметрична для RU<->EN букв и части знаков, но нет проверки на целостность и соответствие всем спецсимволам/цифрам.

### Исключения и стабильность
- Исключения ловятся только внутри функций переключения раскладки (`switch_keyboard_layout_gnome/kde`), остальные операции (clipboard, hotkey) не защищены (см. `layout_switcher.py:61-93`, `layout_switcher.py:135-177`).
- При исключении до восстановления буфера обмена может произойти потеря/замена буфера.

### Возможные race conditions (clipboard)
- Паузы `time.sleep(0.15)` используются как фиксированные тайминги для операций копирования/вставки (см. `layout_switcher.py:148-175`).
- Если другая программа меняет буфер обмена в этот момент, будет потеря чужого содержимого или неправильная вставка.

### Тайминги/sleep и риски
- Фиксированные задержки не учитывают скорость приложения/нагрузку/задержки оконной системы — риск слишком раннего чтения/восстановления буфера.

## 4. Ошибки и риски
### Критические
- **Вставка “не того” текста при отсутствии выделения.** Если выделения нет, буфер не меняется, но скрипт берет `original_clipboard`, конвертирует его и вставляет в активное окно. Это приводит к вставке чужого содержимого и потенциальной порче текста (см. `layout_switcher.py:135-168`; закомментирована проверка `selected_text == original_clipboard` на `layout_switcher.py:155-158`).
- **Падение при ошибке доступа к буферу.** `pyperclip.paste()` вызывается до проверки и без обработки исключений, что может завершить процесс и оставить буфер в измененном состоянии (см. `layout_switcher.py:135-139`).

### Средние
- **Wayland (GNOME 46) не поддерживает глобальные хоткеи/clipboard** через `pynput`/`pyperclip` по умолчанию → скрипт может вовсе не работать без X11/XWayland.
- **Переключение раскладки в GNOME** жестко переключает индекс 0↔1, некорректно при >2 раскладках (см. `layout_switcher.py:61-67`).
- **Неустойчивые тайминги** (0.15s) → возможна вставка старого/исходного буфера, если вставка читает буфер позже (см. `layout_switcher.py:148-175`).

### Низкие
- `print(args)` в `__main__` засоряет журнал systemd (см. `layout_switcher.py:207-210`).
- `systemd/*.service` используют жестко заданные `DISPLAY` и путь `ExecStart` — легко ломается при другой установке (см. `systemd/layout_switcher.service:10-16`).
- `start.sh` строго требует `venv` и не подсказывает, как его создать/обновить зависимости (см. `start.sh:9-15`).

## 5. Улучшения (приоритеты)
### P0 (обязательно)
- Защита от вставки при отсутствии выделения: сравнивать `selected_text` с `original_clipboard` и/или проверять изменение буфера после Ctrl+C (см. `layout_switcher.py:155-158`).
- Обернуть работу с буфером в `try/finally`, чтобы гарантировать восстановление даже при исключении.

### P1 (желательно)
- Логирование через `logging` с уровнями и выводом в journald: отдельные сообщения для “горячая клавиша”, “буфер пуст/не текст”, “ошибка переключения” (см. `layout_switcher.py` и systemd unit’ы).
- Graceful shutdown: корректно закрывать listener по сигналам и логировать завершение.
- Защита clipboard: контекст-менеджер/lock или проверка “собственного” clipboard-формата (например, метка/хеш) перед восстановлением.
- Исправить unit под X11: убрать жесткий `DISPLAY=:0`, читать из окружения user session, проверить `ExecStart` и `WorkingDirectory` (см. `systemd/layout_switcher.service`).

### P2 (по возможности)
- Wayland-заметки: документировать, что глобальные хоткеи не работают в чистом Wayland; варианты обхода — запуск X11-сессии, XWayland, GNOME Shell Extension, или переход на инструменты с поддержкой Wayland (уточнить в README).
- Для GNOME с >2 раскладками: менять раскладку через список input sources, а не жестко 0↔1.

## 6. Быстрый чек-лист тестирования
### Ручная проверка
1. Запустить `start.sh` в активной X11-сессии.
2. Открыть текстовый редактор, набрать текст в “не той” раскладке, выделить.
3. Нажать Scroll Lock/Win → текст должен замениться на конвертированный и системная раскладка должна переключиться.
4. Проверить, что исходный буфер обмена восстановлен (вставить в другое место).

### Типовые сценарии
- Есть выделение → текст заменяется корректно; буфер возвращается.
- Нет выделения → **ничего не должно вставляться** (сейчас это не так).
- Буфер содержит не текст (изображение/файл) → скрипт не должен падать.

### Диагностика проблем
- “Не ловит клавишу”: проверить `XDG_SESSION_TYPE`, наличие X11/XWayland, права на перехват; убедиться, что `pynput` работает в текущей сессии.
- “Не вставляет”: проверить доступ к буферу (`pyperclip`), наличие `xclip/xsel`, корректный `DISPLAY`/`XAUTHORITY`.
- “Ломает буфер”: проверить восстановление clipboard и конкурирующие приложения, посмотреть логи systemd (`journalctl --user -u layout_switcher.service -f`).
